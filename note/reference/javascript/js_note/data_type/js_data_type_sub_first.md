- [Back to Main](../../../head.md)
- [Back to Submain](../../js_main.md)

---

- Number

  MDN을 처음 펴 본 여러분은 시작과 동시에 묘한 기분이 들 수 있을겁니다.

  IEEE-754? 이중정밀도 64비트 지원? 이게 뭐야? 무슨 말이야? 하고 말이죠 ㅎㅎ.. 제가 그랬거든요.

  그래서 간단하게 설명해드리자면, binary digit 의 할당 크기만큼 소수점에 대한 표기를 한다는 것인데요.

  이전에 아마도 부동소수점이라는 개념을 우린 어렸을 때 한 번 맛보기로 접했을겁니다. (중~고등학교 사이 교육과정에 있지 않았나 싶네요)

  그 부동소수점 표기에 대한 말입니다.

  대부분의 프로그래밍 언어는 주로 3가지 부동소수점 표현을 지원하는데, C 언어에서의 float, double은 그 방식의 구분입니다.

  32binary digit 표기를 지원한다면 float32를 의미하구요, 이런 표현방법은 지수부의 bit에 따라 2의 -126승부터 128승 즉, 2^-126 ~ 2^128 사이의 수를 사용하고, 표기할 수 있게 해줍니다.

  그렇다면 우리가 사용하는 Js는 어떨까요? 네. 맞습니다. 첫 줄에 나와있는 이중정밀도(배정밀도) 64bit 에 해당하는 실수표현을 기본으로 사용한답니다.

  이게 무슨 말일까요?

  1. 정수개념이 다르다.

     Js에서는 Integer 개념이 존재하지 않고, 자연계에 존재하는 실수가 곧 정수인겁니다. (BigInt는 엄연히 다른 개념입니다. 착각하시면 안됩니다.)

     즉, Js는 우리가 코딩에 0.1을 집어넣더라도, 실제 내부 연산에서는 .100000... 으로 이루어진 64bit double 실수를 활용한다는 것이죠.

     다만, 이러한 불편함을 해소하기 위해 기존 프로그래밍 언어 기준의 정수를 처리하는 작업에서는 32bit 정수를 구현합니다.

     이 범위는 **-2^31 ~ (2^31 - 1, 2^31인 시점에서는 bit 초과)** 로 정의됩니다.

     64bit double에 해당하는 범위는 지수부만 따져도 -2^1022 ~ 2^1024 이므로, 큰 수를 계산할 일 없는 웹, 앱 개발 내의 어지간한 넘버링으로는 정수처리, 실수처리 양 쪽 모두 다 채울 상황이 거의 없다는 것이죠.

     > 그런데, 만약 정말 만약 이러한 값을 초과하는 연산을 하셔야 하는 상황이 발생한다면 어떻게 해야 할까요?

     > 배열을 통한 bit 극복 방식이 있으니, 정말 필요하시다면 따로 공부를 해봅시다! 저도 나중에 알고리즘을 공부할 때 사용해 볼 방식으로 적어두겠습니다.

  2. 그 이외에도 기본적인 사칙연산 기호 = 표준 산술 연산자(+, -, \*, /)를 지원하고, parseInt()등의 내장함수를 통해 우린 문자열이나 다양한 진법의 수 표현을 오갈 수 있습니다.

  3. 계산이 더 복잡하고, 공학적인 사항이 요구될 때는 Math라는 내장 obj를 활용할 수 있도록 지원하고 있답니다. (Python에도 있죠?)

  4. parseInt()의 활용법

     우리의 parseInt()는 상당히 많은 역할을 합니다.

     먼저, String 형태의 숫자 data를 number로 변환해줄 수 있습니다.

     둘째, 다양한 진법 (2, 8, 10, 16)의 수를 매개변수로 지정해주면 해당 정수를 진법에 맞게 바꿔주기도 합니다.

     ex1)

     `parseInt('01', 2); // 1`

     이와 같이 말이죠. 보시는 것과 같이 2는 매개변수로 들어가있고, 이는 2진법을 의미합니다.

     또한 String이 숫자가 아닌경우에는 "NaN"이라는 독성을 가진 값을 반환하는데요, 이 때 주의하셔야 할 점은 독성을 가졌기 때문에 계산식 끝, 처음, 혹은 어딘가에서 NaN이 반환되었다면, 무조건 최종 결과는 NaN으로 반환되기 때문에 주의하셔야 합니다.

     이를 위해 우리는 isNaN() 함수를 사용해 반환값을 검사할 수 있습니다.

  5. Infinite, -Infinite

     무한을 뜻하는 값을 Js는 가지고 있습니다.

  6. "+"연산자와 parseInt()

     대부분 + 연산자에 대해 들어는 보셨을겁니다. String 값을 단항연산자를 활용해 숫자로 변환해주는 녀석이죠.

     문제는 String 내부에 숫자도 존재하지만, 글자가 함께 섞여있는 경우입니다.

     `123a456b789c` 라는 String 값을 parseInt()로 볼 경우 NaN이 나오지는 않습니다. 글자 이전에 등장하는 숫자를 반환해주기 때문이죠.

     단, "+"연산자의 경우 글자가 섞여있다는 것 하나만으로 바로 NaN을 반환합니다.

     이런 경우를 주의하시며, 코드를 작성하시기 바래요.

  적다보니 Number에 대한 설명이 꽤 길어졌네요. 가독성을 위해 다음 페이지에 다시 작성하도록 하겠습니다.

  이번 페이지는 생각보다 더 알고리즘 테스트에 필요한 영역이었지 않을까 싶어요. 매우 기초적이지만, 사실 대부분의 알고리즘 영역의 문제는 인간의 착각에서 발생하니까요.

- String

  Js에서의 문자열은 우리가 늘 지정해주던 HTML 내의 UTF 형식을 기본으로 탑재하고 있습니다.

  신경쓸 부분이 줄어든 점에서 상당히 기쁘지 않나요? 심지어 우린 어느 국가의 언어든 다 표현할 수 있습니다.

  UTF-16 코드의 나열로 이루어진 문자열을 통해서요! 이건 정말 기쁜 일이지만, 사실 요즘 언어에서는 당연한 일이기도 하죠.

  그러니 우린 편하게 Js에서 문자열을 활용하면 된답니다.

- Boolean

  Js에서는 당연히 다양한 용도에 쓰일 수 있는 true, false 값을 가지고 있습니다.

  이는 조건문에 주로 사용되는 형태로, 우린 Boolean을 활용해 다양하고, 동적인 웹, 앱의 애니메이션을 만들어 볼 수 있겠죠.

- null, undefined

  Js는 값이 없는 상태를 나타내는 데에 null과 undefined를 활용합니다.

  둘은 말 그대로 비어있다, 정의되지 않았다. 로 지금 설명에서는 Boolean으로 활용 시 false를 의미한다. 정도만 알고 계셨으면 좋겠습니다.

  이후 값에 대한 설명에서 둘은 자세하게 다뤄볼 예정이거든요.

  그 외에도 Boolean으로 치환 및 활용 시 false를 나타내는 값들에는 **0, false, ""(공백 string), NaN(number가 아님)**(+ null, undefined) 등이 있습니다.

  > `Boolean()`function을 사용하면 값을 바꿀 수 있습니다. 그러나, 대부분의 조건에 이러한 값이 반환될 경우, Js는 사용자 몰래 그냥 거짓 or 참의 값으로 알아서 변경해줄겁니다.

  > 즉, 우리가 신경써야 할 부분은 값의 반환이 어떻게 이루어졌고, 어째서 조건의 결과가 `false || true` 로 반환되었는지 정확히 알고만 있으면 된다는 것이죠.

  자, 이것으로 첫 번째 노트인 자료형의 1/3 정도를 맛보기로 보신겁니다.

  마음에 드신다면, 함께 가봅시다.

[Next Page](js_data_type_sub_second.md)
