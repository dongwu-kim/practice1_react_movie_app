- [Back to Main](../../../head.md)
- [Back to Submain](../../js_main.md)

---

- Variable

  이제 객체를 배울 시간이 점점 다가오고 있네요. 객체를 배우기 전에 우린 Js에서 변수를 어떻게 처리하고, 정의하는지 미리 알아두어야 합니다.

  이는 자료형 이전에 설명해도 괜찮은 부분이지만, 자료형을 모르는 상태에서 변수를 선언하는 것은 변수에 부가적인 설명을 요구하기에 MDN에서도 이 순서 쯤에 위치해 있습니다.

  우린 Js를 미리 활용해왔고, 대부분의 선언에서 `const, let, var` 3가지로 변수의 특징을 지정해주었죠.

  이는 저마다 들어가야 할 상황이 조금씩 다르고, 그 결과, 우린 let과 const를 var에 비해 더욱 많이 활용하게 되었습니다.

  1. var와 호이스팅

     Js에서만 나오는 호이스팅의 개념은 var를 통해 이해할 수 있습니다.

     이건 엄연히 Js 개념으로, 프론트엔드 지망생, node.js 백엔드 지망생 여러분들은 한 번 쯤은 생각해도 나쁘지 않은 주제일 것 같습니다.

     물론 var를 왜 지양해야 하는가? 에 대한 검색만으로도 양질의 답변을 얻을 수 있습니다만, 저는 제가 직접 작성하며 이해하고자 합니다.

     먼저, Js의 경우 var를 통한 변수선언 혹은 함수의 선언 당시 어디에 존재하든 미리 알고 있기 때문에 오류가 발생하지 않는다. 라는 것으로 이해하시면 됩니다.

     이건 모든 설명을 관통하는 말입니다.

     ```javascript
     console.log(num); // undefined
     var num = 100;
     ```

     이게 호이스팅의 예시입니다.

     단, 이러한 개념을 증명하는 데에는 scope(범위)가 중요하게 작용합니다. 내부에서 선언된 변수를 외부에서 클로저가 아닌 이상 호출할 수는 없기 때문입니다. 따라서, scope를 항상 유의하며 코드를 작성해봅시다.

     이러한 개념은

     > var 변수선언의 오류는 해당 함수블럭 혹은 전역에서 어느 위치던 간에 범위 내 모든 함수의 "실행 순서"와는 전혀 관계없습니다.

     > 그러나 해당 변수를 활용한 메서드나 함수의 호출에서의 반환값은 순서를 무시하지 않는다는 점이 중요한 포인트입니다. -> 초기화 선언의 순서는 신경을 쓰셔야 한다는 말입니다. 그렇지 않으면 undefined를 관찰하시겠죠.

     이러한 개념의 바탕에는 Js가 **함수나 변수의 "선언"**을 메모리에 저장하기에 가능한 것입니다.

     Js는 함수나 변수의 선언을 메모리에 저장하기 때문에 호출 당시 함수의 args or param의 변경사항을 어디서든 반영할 수 있습니다. 함수가 호출보다 먼저 선언되었든, 나중에 선언되었든 말이죠.

     이를 설명하기 위해 많은 사람들은 **"선언 자체를 위로 끌어올린다."**는 표현을 사용합니다.

     그게 더 쉽게 이해되기 때문이죠, 그게 편하시다면 우리가 사용하던 기존 cascading code 작성 비유를 통해 이해하시면 됩니다.

     그게 아닌, 실제로는 메모리에 먼저 저장하기 때문에 선언의 위치는 크게 관계가 없다는 것이죠.

     자, 이와 같이 var는 호이스팅의 개념을 증명하는 선언방식입니다.

     const와 let은 그렇지 않죠. 왜일까요?

  2. TDZ(Temporal Dead Zone)

     Hoisting에 대해 우린 이제 이해했습니다. 그렇다면 왜 변수 선언에서는 const, let을 사용하는지 알아야겠죠.

     우리가 실제 const, let을 사용하는 이유는 사실 지극히 실용적으로 말할 수 있습니다.

     "유지보수에 쉽고, 디버깅에 유용하니까."

     이보다 더 효율적인 이유가 있을까요?

     그 배경에 있는 것이 바로 TDZ입니다.

     어휘적 바인딩이나, 그 외 환경에 대한 설명을 빼곡히 늘어놓으려면 이 md 파일은 가독성이 지금보다 더 떨어질테니, 간략하게 논해보자구요.

     그러한 개념을 배제하면, const와 let은 초기화 단계의 실행이 필수적인 선언들이기 때문입니다.

  3. 전역변수

     우린 OOP 언어를 활용합니다. 이러한 언어에서 무분별한 전역변수의 사용은 어떻다고 했었죠?

     네. 맞아요, 선언된 변수( = 객체)가 이후 참조될 경우 원본에 의도치 않은 영향을 끼칠 수 있는 상황이 온다고 말씀드렸습니다.

     동명의 변수를 지정할 경우, 해당 변수를 사용하는 함수들 전체에 영향을 끼치는 것은 물론, 어디서 왜 꼬였는지 모를 아주 거지같은 상황이 발생하죠.

     > 특히나, 자바스크립트는 거지같은 객체참조를 지원하고 있다고 [forEach(), map()](../../../../step2\2_Dynamic_Components.md) 메서드 설명에서 말했었죠.

     그럼에도 우린 전역변수를 부득이하게 선언해야 하는 상황이 있습니다.

     그래서 상수로 지정을 하게 되는 것이죠.

     다른 파일에서 같은 변수를 선언하더라도 export 하지 않는다면 값을 사용할 수 없고, 애초에 수정이 불가능한 `const` 라는 선언을 통해서요.

     자, 이제 어느정도 이해가 가셨나요?

     우리가 const, let을 활용하는 이유는 다음과 같이 정리할 수 있겠네요.

     > `const`는 전역변수 혹은 블럭 내의 지역변수의 선언 시 값의 변경을 원하지 않는 것으로 해석하시면 됩니다. (주로 DOM에 해당하겠죠.)

     > `let`은 value의 변경의 가능성이 있는 지역변수를 선언한다는 의미입니다. **(이건 그냥 일종의 약속이에요. 전역으로 사용해도 무관합니다만, 전역변수는 최대한 피해야 하니까요.)**

     추후 나올 복사에 대한 개념과 함께 설명하고 싶지만, 우선은 간략하게만 알고 계시기 바랍니다.
