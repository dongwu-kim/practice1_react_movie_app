- [Back to Submain](../head.md)

1.  OOP? POP?

    > 이게 뭔데 자꾸 등장하는지 모르겠고, 우리의 웹, 앱 개발에 있어 왜 이런 말이 필요한지 모르시겠다구요?

    여러분은 살면서 **'객체지향 프로그래밍'**이라는 말을 들어보셨나요? 아니면 반대로 **'절차지향 프로그래밍'** 이라는 말은 들어보신 적 있으신가요?

    저는 대학 4년 내내 그러한 말을 들어본 적 없었고, 지금도 독학하는 중에 모호한 개념이라고 생각합니다.

    이러한 개념들은 왜 제게 있어 모호하고, 어렵게 느껴질까요? 그 이유에는 많은 것들이 있겠지만, 무엇보다도 제대로 공부한 적 없는 분야의 지식이라 그렇겠죠?

    그래서 더욱 쉽게 이해하고, 나아갈 수 있도록 이번 기회에 풀어보려고 합니다.

    제 필기를 보시는 분들이 존재하고, 그러한 분들께서 C언어에 대한 배경지식만을 가지고 계시거나 혹은 전혀 언어에 대한 배경지식이 없으신 분들이라는 가정을 하고 시작하도록 하겠습니다.

    1. OOP의 3요소

    이번 파트를 통해 여러분은 본격적으로 객체지향 프로그래밍 언어의 3요소에 대해 생각하는 시간을 가지게 될겁니다.

    이번 내용은 Polymorphism, Encapsulation, Inheritance 3가지에 대한 내용이며, 혼자만의 지식보다는 오랜기간 쌓여온 프로그래머 분들의 지식을 열심히 종합해 쉽게 적어보려 합니다.

    - skip 구간(잡소리)

    프로그래밍적인 사고를 지향하시는 분들이라면 분명 외부의 문제를 가져온 다음, 컴퓨터로 이를 해결하고자 하는 욕구가 존재할겁니다.

    이 과정에는 분명 다양한 방법론들이 존재하고 있을겁니다. 그러나, 모든 방법들에는 빼놓을 수 없는 과정이 존재하는데요.

    어떤 문제를 해결할 것인지 고려하는 과정입니다. 참 당연하죠? 즉, 우리가 '어떤' 문제를 해결할지를 고민하고, 명확하게 구현해야 한다는 것이죠.

    이것은 아주 중요한 절차입니다. 어떤 문제를 해결할지 고민하는 것에 익숙하지 않으면 정말 개선이 필요한 문제는 뒤로 한 채 세부적인 디테일부터 손을 댄 다음 구현단계에서 지속적으로 헤매게 되거든요.

    저도 그러한 시도를 많이 했고, 그 결과는 이도저도 아닌 하드코딩의 반복으로 이어지고는 했습니다.

    그렇다면 웹과 앱을 개발한다면, 우리의 문제는 어디에서 올까요?

    네 맞습니다. 우리의 문제는 대부분 Clients에게서 오게 될 겁니다. 그러한 문제들은 때로 유저들의 직접적인 요구사항일 수 있고, 늘 그렇듯 개발자의 관점에서 바라본 유저의 불편함(추정)일 수 있습니다.

    즉, 추정하는 것으로 우린 보다 더 나은 결과물을 내놓을 수 있게 되는겁니다. 추정하고, 예상하고, 그리고 그 결과들을 꺼내오는 것. 우리의 숙제는 문제를 꺼내오는 일에서 시작하게 되는 것이죠.

    그러니 우린 문제를 잘 '추정'해야 합니다. 개발시간을 잡아먹을 수 있는 불필요한 구간을 모두 막아두기 위해서요.

    이후 문제라는 배낭을 집어들었다면, 우린 이제 원하는 길로 떠나면 되는 겁니다.

    그 길의 첫 장애물은 Abstraction, 추상화입니다.

    - Polymorphism(다형성)과 Abstraction(추상화)

    > Abstraction이라는 말을 보면 뭔가 글자들의 조화도 멋진 것 같고, 발음도 섹시하지 않나요? 심지어 뜻도 날카로워 보이는게 제가 아는 단어 중 최고인 것 같네요

    추상화는 잡소리에서 얘기했듯, 추정하는 것의 세부적인 개념입니다.

    문제를 선택했다면, 우리는 문제를 해결하기 위한 필수적인 정보들이 필요하게 됩니다.

    예를 들어, 라면을 전보다 더 '잘' 끓이는 방법을 view에 표시하는 것을 문제라고 해볼까요?

    그럼 물의 온도, 스프와 물의 비율, 조리시간 등을 요구하게 될겁니다. 이는 다시 말하면 숫자의 형태를 가진 데이터겠네요.

    temp, ratio, time 이렇게 놓고 보면 딱 봐도 아, 이건 숫자들로 이루어진 변수겠구나! 할 수 있겠죠?

    이게 바로 추상화입니다. 변수의 이름만 보고도 value의 data type을 유추할 수 있다는 것은 아주 훌륭한 추상화가 반영된 것으로 이해하실 수 있겠습니다.

    그렇다면 이러한 값들은 보는 사람이 최고의 라면을 만들어내기까지 지속적으로 다른 값으로 변할겁니다. 어쩌면 숫자가 아닌 글자의 값을 넣어주어야 할지도 모르고요.

    기존에 minute 단위를 쓰던 time을 ms, s 단위로 바꾸거나, 아니면 '3분 43초' 라는 string 값을 넣어주면 user의 입장에서는 더 알아보기 쉽겠죠.

    이제 추상화된 데이터들을 변화시키는 과정을 통해 OOP가 갖는 첫번째 특성이 나타나게 됩니다.

    만약 우리가 조리시간(time - number)을 사용자에게 편한 (time - string)문자열로 변경해서 출력하고자 한다면 이러한 역할을 수행해줄 함수나 메서드를 활용해야겠죠.

    그러나 Polymorphism을 가지지 않는다면, 아마도 number를 string으로 변환하는 기능만을 가지는 함수를 사용해야 할겁니다.

    하지만 Polymorphism을 지원하는 언어라면 어떨까요? 변경하고자 하는 data의 type에 의존하지 않는 함수를 사용할겁니다.

    예를 들자면

    ```java
    //숫자를 문자열로 바꾸는 경우
    string = StringFromNumber(number);

    //날짜를 문자열로 바꾸는 경우
    string = StringFromDate(date);
    ```

    이러한 방식은 Monomorphism을 가지는 언어에서의 선언이 될 것입니다. 보시다시피, 하나의 data type에 하나의 함수를 직접 할당하고 있는 개념이죠.

    ```java
    //숫자를 문자열로 바꾸는 경우
    string = number.StringValue();

    //날짜를 문자열로 바꾸는 경우
    string = date.StringValue();
    ```

    이러한 방식은 Polymorphism을 지원하는 언어에서의 선언입니다. 보시면 차이가 선명하게 드러나죠?

    즉, 다향성을 갖는 언어에서의 추상은 보다 더 직관적이고, 유지보수에 있어 유용하다는 것을 알 수 있습니다. data type에 구애받지 않기에 어떠한 data가 오든 하나의 메서드를 활용해 string으로 치환할 수 있는 것이죠.

    data Abstraction에 있어 Polymorphism의 지원은 상당히 유용하겠죠? 그렇다고 해서 단형성(Monomorphism)을 갖는 언어가 '구식'이라는 것이 아닙니다. 분명 장단점이 존재하죠. 엄격한 함수의 사용과 정교한 디버깅을 원한다면 Monomorphism은 작성이 번거로울 뿐 상당히 매력적일 수 있습니다. -> 뇌피셜😥😥

    그러나 우리가 사용하는 Java라는 언어는 분명히 다형성을 지원하고, 우린 이를 통해 손쉬운 data 처리가 가능함을 인정할 수 밖에 없겠습니다.
