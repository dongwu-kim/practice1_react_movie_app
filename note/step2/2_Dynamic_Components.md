2. [Dynamic Components (function-components basic)](2_Dynamic_Components.md)

- [Back to Main](../../README.md)

현재 장의 노트

- **2.1 Array, map()**

- [2.2 Father 내 img 태그 작성](2_img.md)

- [2.3 Id-Key](2_id-key.md)

- [2.4 prop-types](2_prop-types.md)

- Components를 Copy & Paste로 작성할 수는 없습니다.

  > 물론 그러한 작성방식이 문제가 되는 것은 아닙니다. 그러나, 상대적으로 아름다운 코드를 작성하고 싶고, 유지보수를 쉽게 하기 위한 방법을 생각한다면 중복이 많은 Code는 지양해야 합니다. (메서드의 경우는 처리하는 이벤트에 따라 달라지지만 ㅠㅠ)

- 이에 우리는 새로운 방식으로 Code를 작성할 줄 알아야 합니다.

  - 2.1 Array, map() ? 그게 뭔데 ?

    - 먼저 Array에 대해서는 자세한 설명을 생락합니다. 자료구조에 대한 이해는 나중에 따로 Java를 다루며 설명할 수 있는 기회를 마련하고자 합니다.

      > 다만 쉽게 생각하자면, 일종의 자료**보관함**이라고 생각하면 됩니다. 우리가 사용하고자 하는 Data를 언제든 꺼내쓸 수 있고, 보관함 자체를 하나의 Data로 활용하고 싶다면 당연히 그럴 수 있습니다!

    - 그렇다면 이러한 Array는 어디에 활용될까? 방금 써져 있듯, 우리는 `map()`이라는 기가 막힌 메서드를 호출하여 보관함의 역할을 보다 더 가시적으로 이해할 수 있게 될 것입니다.

    - 2.1.1 `map()`, `forEach()` ? 뭘 써야 할까 ?

      우선 용어의 혼용을 이해하기 위해 앞으로 우리가 정의한 함수, 즉 JSX 방식을 적용한 App.js 내의 함수들은 Class를 가지지 않기 때문에 함수라고 표현하겠습니다.

      그러나 우리가 내장함수를 불러올 경우에는 **메서드**라는 표현을 활용할 것이기 때문에, 글을 이해하기 어렵다면 쉽게 아, 이건 다른 사람들이 만들어놓은 함수구나!(라이브러리 내장함수) 하고 생각하면 됩니다.

      이전 Vanilla JS를 공부했던 때에 저는 `forEach()`와 `map()`을 활용한 경험이 거의 없습니다. 애초에 웹 디자인 측면에 조금 더 치우친 공부를 하다 보니 Array 요소 모두에 같은 메서드를 적용시키더라도 조금씩 세밀하게 컨트롤을 했어야 했고, 그냥 생각하는 힘을 기르기 위해서라도 **for문을 활용한 반복문**등을 극한으로 활용했습니다.

      자, 서론이 길어졌지만 map()에 대해 얘기해봅시다, 방금도 말했듯 우리는 forEach()와 map()을 동일선상에 놓는 오류에 빠질 수 있습니다. 하지만, 엄연히 말하자면 이 둘은 같은 역할을 하는 것 처럼 보이지만 전혀 다른 메서드라고도 볼 수 있습니다.

      forEach()의 경우 Array 내부 각 요소에 대한 콜백함수가 실행된 후 리턴값이 없기에 **수정**의 기능을 하는 메서드입니다.

      map()의 경우 콜백을 모든 요소에 수행한 뒤, 동일한 크기를 가지는 배열을 결과로 반환하는 **재생성**기능의 메서드입니다.

      즉, 두 메서드는 `console.log()`에서는 같은 기능처럼 보이지만 엄연히 원본에 대한 보존이 되느냐, 아니느냐 라는 차이를 가지게 됩니다.

      > **그렇다면 랜더링 개선에 있어 map()과 forEach()중 어떤 것이 최적화에 있어 유용할까?**

    - 2.1.2 `forEach() & map()`의 사용처

      <!--
               | forEach()                     | map()                              |
               | ----------------------------- | ---------------------------------- |
               | Array 요소 인덱스로 호출      | Array 요소 인덱스로 호출           |
               | 해당 요소 콜백 적용           | 해당 요소 콜백 적용                |
               | 해당 요소 인덱스로 Array 호출 | 새로운 Array 내 동일 인덱스에 반환 |
               | Array 요소 콜백요소로 수정    | 배열 길이만큼 반복                 |
               | output = 수정된 요소의 값     | Array로 전체 결과를 반환           |
               | 배열 길이만큼 반복            |                                    |-->

      속도에 있어 map()은 forEach()에 비해 70%정도 빠릅니다.

      이건 참 아이러니하지 않은가요? 분명, 콜백을 실행하고, 새로 배열을 창조한 다음 반환까지 하는데 왜 map()이 더 빠를까요?

      > 그 이유는 forEach()의 경우 **수정**의 과정을 거치기 때문이라는 생각이 들었습니다.

      그렇다면 이러한 과정을 1번, 2번이 아닌 1억번을 사용해야 한다는 생각을 한다면 누구나 map()을 사용해야 하는 것이 바람직하지 않을까요?

      - 그러나 엄연히 그런 것은 아닙니다. map()은 말했다시피 원본의 보존이 이루어짐과 동시에 새로운 **배열**을 만들어내기 때문에 **수학적 계산이 필요한 부분에 있어서는 결과를 배열이 아닌 숫자로 반환할 수 있는 forEach()를 활용하는 것이 좋습니다.**

      - 주의해야 할 점은 forEach()의 경우 **반환값이 없기 때문에** 콜백의 계산값을 연속적으로 사용하기 위해서는 새로운 변수에 계산된 값을 return하거나, 모든 콜백체인(또는 프로미스), 외부함수 내부에서 원본 Array자체를 사용해야만 합니다.

      map()은 매번 새로운 배열을 생성하기 때문에 위와 같은 문제는 없으나, 반대로 retrun이 없을 경우 당연하게도 메서드 자체가 휘발성을 가집니다.

      또한, map()의 경우 새로운 Array를 창조하기 때문에 메모리가 할당된다는 점을 유의해야 합니다. 이는 수많은 트래픽을 감당해야 하는 경우에 특히 고려해야하는 문제입니다.

      - JS에서 주의해야 할 사항

        > `map(), forEach()` 모두 고급스러운 방식의 for문이라 봐도 무방합니다. 우리는 이 메서드를 자주 이용하고, 또 사랑하고 있죠.

        문제는 우리가 해당 메서드를 반응형 웹이나, 동적인 애니메이션을 제작할 때 항상 사용하게 된다는 점에서 시작됩니다.

      - 객체참조? 대체 나한테 왜 그러는데?

        JS는 안타깝게도 map(), forEach() 어느 메서드건 간에 Object로 요소가 구성된 Array에 대한 배려를 하지 않습니다.(뛰어난 웹을 위해서인데 DOM elements Array를 이렇게 불편하게 한다고?)

        심지어 우리의 구세주인 const 선언 따위로는 **객체참조**를 막을 수 없다는 점에서 우린 절망하게 됩니다. (property 내용은 수정이 가능하고, property 항목 추가를 할 수 없기 때문입니다.)

        > 이에 웹 개발 시에 map()을 사용할 때는 반드시 새로운 배열을 가지는 변수를 지정해줍시다.

        > 예1)

        ```javascript
        const arr = [{greeting:`hi`, text:`i'm dongwu`},];
        const newArr = arr.map((obj)=> {
          retrun obj.greeting = `good morning`;
        })
        ```

        위와 같이 새로운 배열을 만들어주지 않는다면, 아마도 당신은 원본 배열의 property 변화를 실시간으로 경험할 수 있을 것입니다. 🧔

        그게 아니더라도, 저런 습관을 들이면 언제든 꼬일 일은 없지 않을까요?
